name: Protect stale/* branches (read-only archive)

on:
  # Runs when a branch or tag is created.
  # This is the most reliable trigger for "rename to stale/*" because a rename
  # typically becomes: create new stale/* branch + delete old branch.
  create:

  # Manual run, useful if you need to re-apply protection to existing branches.
  workflow_dispatch:

permissions:
  # Needed for reading repo contents; branch protection changes require a token
  # with repo administration rights (see notes below).
  contents: read

jobs:
  protect-stale-branches:
    runs-on: ubuntu-latest
    steps:
      - name: Determine target branch
        id: branch
        shell: bash
        run: |
          set -euo pipefail

          # For `create` events, GitHub provides ref_type (branch/tag) and ref (name)
          # For workflow_dispatch, weâ€™ll use GITHUB_REF_NAME
          if [[ "${GITHUB_EVENT_NAME}" == "create" ]]; then
            echo "ref_type=${{ github.event.ref_type }}" >> "$GITHUB_OUTPUT"
            echo "ref_name=${{ github.event.ref }}" >> "$GITHUB_OUTPUT"
          else
            echo "ref_type=branch" >> "$GITHUB_OUTPUT"
            echo "ref_name=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"
          fi

      - name: Skip if not a stale branch
        shell: bash
        run: |
          set -euo pipefail
          ref_type="${{ steps.branch.outputs.ref_type }}"
          ref_name="${{ steps.branch.outputs.ref_name }}"

          if [[ "$ref_type" != "branch" ]]; then
            echo "Not a branch (ref_type=$ref_type). Skipping."
            exit 0
          fi

          if [[ "$ref_name" != stale/* ]]; then
            echo "Branch '$ref_name' does not match stale/* . Skipping."
            exit 0
          fi

          echo "Will protect stale branch: $ref_name"

      - name: Apply branch protection (read-only archive)
        env:
          # IMPORTANT:
          # This must be a PAT (classic or fine-grained) with permission to edit branch protection.
          # Store it in repo/org secrets as STALE_BRANCH_PROTECTOR_TOKEN.
          GH_TOKEN: ${{ secrets.STALE_BRANCH_PROTECTOR_TOKEN }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          BRANCH: ${{ steps.branch.outputs.ref_name }}
        shell: bash
        run: |
          set -euo pipefail

          if [[ -z "${GH_TOKEN:-}" ]]; then
            echo "Missing secrets.STALE_BRANCH_PROTECTOR_TOKEN"
            echo "Create a token with repo admin/branch protection permission and add it as a secret."
            exit 1
          fi

          echo "Protecting ${OWNER}/${REPO} branch '${BRANCH}' ..."

          # Apply full protection. This aims for "read-only archive":
          # - no direct pushes
          # - PRs required (but you can also lock it down further by restricting who can push)
          # - force-push disabled
          # - deletions disabled
          #
          # If you want to allow *only admins* to push in emergencies,
          # put an allowed team/user into restrictions (see notes).
          gh api \
            -X PUT \
            "repos/${OWNER}/${REPO}/branches/${BRANCH}/protection" \
            -H "Accept: application/vnd.github+json" \
            -f required_status_checks.strict=false \
            -f enforce_admins=true \
            -f required_pull_request_reviews.dismiss_stale_reviews=true \
            -f required_pull_request_reviews.require_code_owner_reviews=false \
            -f required_pull_request_reviews.required_approving_review_count=1 \
            -f restrictions.users='[]' \
            -f restrictions.teams='[]' \
            -f restrictions.apps='[]' \
            -f required_linear_history=true \
            -f allow_force_pushes.enabled=false \
            -f allow_deletions.enabled=false

          echo "Protection applied to '${BRANCH}'."

      - name: Summary
        shell: bash
        run: |
          echo "If the branch is still writable, check: token scopes/permissions, org policies, or branch protection rule conflicts."
